import pytest
import sys
import os
import json
from fastapi.testclient import TestClient
from datetime import datetime, timezone

# Add backend to path
backend_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'backend')
sys.path.insert(0, backend_path)

from main import app
from auth.utils import hash_password, verify_password

client = TestClient(app)

# ===== BASIC ENDPOINT TESTS =====
def test_read_root():
    """Test root endpoint"""
    response = client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert "app" in data
    assert data["app"] == "Hypersend"
    assert "version" in data

def test_health_check():
    """Test health check endpoint"""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}

def test_favicon():
    """Test favicon endpoint"""
    response = client.get("/favicon.ico")
    assert response.status_code in [200, 204]

# ===== PASSWORD HASHING AND VERIFICATION TESTS =====
def test_password_hash_generation():
    \"\"\"Test that password hashing generates secure hashes\"\"\"\n    password = \"TestPassword123!\"\n    hash1 = hash_password(password)\n    hash2 = hash_password(password)\n    \n    # Hashes should be different due to random salt\n    assert hash1 != hash2\n    # Both should have the format salt$hash\n    assert \"$\" in hash1\n    assert \"$\" in hash2\n    # Salt should be 32 chars, hash 64 chars\n    parts1 = hash1.split(\"$\")\n    assert len(parts1) == 2\n    assert len(parts1[0]) == 32  # salt\n    assert len(parts1[1]) == 64  # hash\n\ndef test_password_verification_success():\n    \"\"\"Test successful password verification\"\"\"\n    password = \"MySecurePassword123\"\n    hashed = hash_password(password)\n    \n    # Correct password should verify\n    assert verify_password(password, hashed) is True\n\ndef test_password_verification_failure():\n    \"\"\"Test password verification with wrong password\"\"\"\n    password = \"MySecurePassword123\"\n    wrong_password = \"WrongPassword123\"\n    hashed = hash_password(password)\n    \n    # Wrong password should NOT verify\n    assert verify_password(wrong_password, hashed) is False\n\ndef test_password_verification_invalid_hash():\n    \"\"\"Test password verification with invalid hash format\"\"\"\n    password = \"MySecurePassword123\"\n    invalid_hash = \"not_a_valid_hash\"\n    \n    # Invalid hash should return False, not crash\n    assert verify_password(password, invalid_hash) is False\n\ndef test_password_verification_empty_password():\n    \"\"\"Test password verification with empty password\"\"\"\n    hashed = hash_password(\"SomePassword\")\n    \n    # Empty password should return False\n    assert verify_password(\"\", hashed) is False\n    assert verify_password(None, hashed) is False\n\n# ===== 400 BAD REQUEST TESTS =====\ndef test_invalid_email_format_400():\n    \"\"\"Test 400 error for invalid email format\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"name\": \"Test User\",\n        \"email\": \"not-an-email\",\n        \"password\": \"password123\"\n    })\n    assert response.status_code == 400\n    assert \"error\" in response.json()\n\ndef test_short_password_400():\n    \"\"\"Test 400 error for password too short\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"name\": \"Test User\",\n        \"email\": \"test@example.com\",\n        \"password\": \"123\"  # Too short\n    })\n    assert response.status_code == 400\n    assert \"error\" in response.json()\n\ndef test_missing_required_fields_422():\n    \"\"\"Test 422 error for missing required fields\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"name\": \"Test User\"\n        # Missing email and password\n    })\n    assert response.status_code == 422\n    data = response.json()\n    assert \"validation_errors\" in data or \"errors\" in data\n\n# ===== 401 UNAUTHORIZED TESTS =====\ndef test_invalid_password_401():\n    \"\"\"Test 401 error for invalid password during login\"\"\"\n    # This assumes a user with test@example.com exists\n    response = client.post(\"/api/v1/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"WrongPassword123\"\n    })\n    # Should be 401 if user exists, or 401 if user doesn't exist (security)\n    assert response.status_code in [401, 503]  # 503 if DB not available\n\ndef test_missing_password_401():\n    \"\"\"Test 401 error when password is missing\"\"\"\n    response = client.post(\"/api/v1/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"\"\n    })\n    assert response.status_code == 400  # Should be 400 for invalid input\n\ndef test_missing_email_401():\n    \"\"\"Test 401 error when email is missing\"\"\"\n    response = client.post(\"/api/v1/auth/login\", json={\n        \"email\": \"\",\n        \"password\": \"password123\"\n    })\n    assert response.status_code == 400  # Should be 400 for invalid input\n\n# ===== 409 CONFLICT TESTS =====\ndef test_duplicate_email_409():\n    \"\"\"Test 409 error for duplicate email during registration\"\"\"\n    # Register a user\n    user_data = {\n        \"name\": \"Duplicate Test\",\n        \"email\": f\"duplicate_{datetime.now(timezone.utc).timestamp()}@example.com\",\n        \"password\": \"Password123!\"\n    }\n    response1 = client.post(\"/api/v1/auth/register\", json=user_data)\n    \n    if response1.status_code == 201:\n        # If registration succeeded, trying again should be 409\n        response2 = client.post(\"/api/v1/auth/register\", json=user_data)\n        assert response2.status_code == 409\n        assert \"already registered\" in response2.json()[\"detail\"].lower()\n\ndef test_case_insensitive_duplicate_email_409():\n    \"\"\"Test 409 error for duplicate email with different case\"\"\"\n    # Register a user\n    user_data = {\n        \"name\": \"Case Test\",\n        \"email\": f\"casetest_{datetime.now(timezone.utc).timestamp()}@example.com\",\n        \"password\": \"Password123!\"\n    }\n    response1 = client.post(\"/api/v1/auth/register\", json=user_data)\n    \n    if response1.status_code == 201:\n        # Try with different case - should also be 409\n        user_data[\"email\"] = user_data[\"email\"].upper()\n        response2 = client.post(\"/api/v1/auth/register\", json=user_data)\n        assert response2.status_code == 409\n\n# ===== 429 TOO MANY REQUESTS TESTS =====\ndef test_rate_limit_headers():\n    \"\"\"Test that rate limit errors include Retry-After header\"\"\"\n    # Try to login multiple times from same IP\n    for i in range(25):  # Exceed MAX_LOGIN_ATTEMPTS_PER_IP (20)\n        response = client.post(\"/api/v1/auth/login\", json={\n            \"email\": f\"test{i}@example.com\",\n            \"password\": \"password123\"\n        })\n        if response.status_code == 429:\n            assert \"Retry-After\" in response.headers\n            break\n\n# ===== ERROR RESPONSE STRUCTURE TESTS =====\ndef test_error_response_includes_timestamp():\n    \"\"\"Test that all error responses include timestamp\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"name\": \"Test\",\n        \"email\": \"invalid-email\",\n        \"password\": \"short\"\n    })\n    assert response.status_code >= 400\n    data = response.json()\n    assert \"timestamp\" in data\n    # Validate ISO format\n    try:\n        datetime.fromisoformat(data[\"timestamp\"].replace('Z', '+00:00'))\n    except:\n        assert False, \"Invalid timestamp format\"\n\ndef test_error_response_includes_path_and_method():\n    \"\"\"Test that error responses include path and method\"\"\"\n    response = client.post(\"/api/v1/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"wrong\"\n    })\n    assert response.status_code >= 400\n    data = response.json()\n    assert \"path\" in data\n    assert \"method\" in data\n    assert data[\"method\"] == \"POST\"\n    assert \"auth/login\" in data[\"path\"]\n\ndef test_400_error_response_structure():\n    \"\"\"Test 400 error response has correct structure\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"name\": \"Test\",\n        \"email\": \"bad@email\",\n        \"password\": \"x\"\n    })\n    assert response.status_code in [400, 422]\n    data = response.json()\n    assert \"status_code\" in data\n    assert \"error\" in data\n    assert \"detail\" in data\n    assert \"timestamp\" in data\n\n# ===== 404 NOT FOUND TESTS =====\ndef test_nonexistent_endpoint_404():\n    \"\"\"Test 404 for non-existent endpoint\"\"\"\n    response = client.get(\"/api/v1/nonexistent\")\n    assert response.status_code == 404\n    data = response.json()\n    assert data[\"status_code\"] == 404\n    assert \"hints\" in data  # Should include helpful hints\n\n# ===== 405 METHOD NOT ALLOWED TESTS =====\ndef test_wrong_method_405():\n    \"\"\"Test 405 for wrong HTTP method\"\"\"\n    # GET on a POST endpoint\n    response = client.get(\"/api/v1/auth/login\")\n    assert response.status_code in [404, 405]  # Depends on routing\n\n# ===== SECURITY TESTS =====\ndef test_no_password_exposed_in_errors():\n    \"\"\"Test that passwords are never exposed in error responses\"\"\"\n    response = client.post(\"/api/v1/auth/register\", json={\n        \"name\": \"Test\",\n        \"email\": \"test@example.com\",\n        \"password\": \"SuperSecretPassword123!\"\n    })\n    response_text = json.dumps(response.json())\n    assert \"SuperSecretPassword123!\" not in response_text\n\ndef test_no_path_traversal_in_404():\n    \"\"\"Test that path traversal attempts return 404 safely\"\"\"\n    response = client.get(\"/api/v1/../../etc/passwd\")\n    assert response.status_code == 404\n    data = response.json()\n    # Should not expose internal paths\n    assert \"etc\" not in data.get(\"detail\", \"\").lower() or \"invalid\" in data.get(\"detail\", \"\").lower()