name: Build & Deploy Backend

on:
  push:
    branches: ["main"]
    paths:
      - "backend/**"
      - ".github/workflows/deploy-backend.yml"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/hypersend-backend

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Wait for Docker Hub availability (retry logic)
        run: |
          echo "ðŸ”„ Checking Docker Hub connectivity..."
          max_attempts=5
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if curl -s -m 10 https://registry-1.docker.io/v2/ > /dev/null 2>&1; then
              echo "âœ… Docker Hub is reachable"
              exit 0
            fi
            attempt=$((attempt + 1))
            if [ $attempt -lt $max_attempts ]; then
              wait_time=$((2 ** attempt))  # Exponential backoff: 2s, 4s, 8s, 16s
              echo "â³ Docker Hub not responding (attempt $attempt/$max_attempts), waiting ${wait_time}s..."
              sleep $wait_time
            fi
          done
          echo "âš ï¸  Docker Hub still not responding, proceeding with login (retry in action will handle)"
          exit 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
        
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        timeout-minutes: 3

      - name: Build & push backend image
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
          cache-to: type=registry,ref=${{ env.IMAGE_NAME }}:latest,mode=max
          build-args: |
            BUILDKIT_CONTEXT_KEEP_GIT_DIR=1
            BUILDKIT_INLINE_CACHE=1
        timeout-minutes: 35
        env:
          DOCKER_CLIENT_TIMEOUT: 600
          COMPOSE_HTTP_TIMEOUT: 600

      - name: Deploy to VPS (Docker Compose, password SSH)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          timeout: 30m
          command_timeout: 30m
          script_stop: false
          script: |
            # Initialize exit status variable
            EXIT_STATUS=0
            
            # Navigate to project directory
            cd /hypersend/Hypersend 2>/dev/null
            if [ $? -ne 0 ]; then
              echo "âŒ Directory /hypersend/Hypersend not found"
              exit 1
            fi

            echo "ðŸ“¦ Starting backend deployment..."

            # Configure Docker daemon with increased timeouts (gracefully skip if permission denied)
            echo "ðŸ”§ Configuring Docker daemon for network resilience..."
            if [ ! -f "/etc/docker/daemon.json" ]; then
              # Try to create daemon.json, but don't fail if sudo is required and not available
              echo '{"default-ulimit": {"nofile": {"Name": "nofile", "Hard": 65535, "Soft": 65535}}, "log-driver": "json-file", "log-opts": {"max-size": "100m"}, "registry-mirrors": ["https://mirror.gcr.io"], "max-concurrent-uploads": 5}' | sudo tee /etc/docker/daemon.json >/dev/null 2>&1
              if [ $? -eq 0 ]; then
                # Try to restart Docker daemon if config was written
                sudo systemctl restart docker 2>/dev/null || sudo systemctl reload docker 2>/dev/null || true
              else
                echo "âš ï¸  Could not write Docker daemon config (may require sudo), continuing with existing config"
              fi
            else
              echo "âœ… Docker daemon configuration already exists"
            fi
            
            sleep 2
            
            # Verify Docker is accessible
            echo "ðŸ” Checking Docker daemon accessibility..."
            docker --version >/dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "âŒ Docker is not accessible, attempting to start Docker daemon..."
              # Try to start Docker daemon
              sudo systemctl start docker 2>/dev/null || {
                echo "âš ï¸  Could not start Docker daemon with systemctl, trying service command..."
                sudo service docker start 2>/dev/null || {
                  echo "âŒ Failed to start Docker daemon"
                  exit 1
                }
              }
              
              # Wait for Docker to start
              echo "â³ Waiting for Docker daemon to start..."
              sleep 10
              
              # Verify again
              docker --version >/dev/null 2>&1
              if [ $? -ne 0 ]; then
                echo "âŒ Docker is still not accessible after restart attempt"
                exit 1
              fi
            fi
            echo "âœ… Docker is accessible"

            # Safely sync repo with remote without creating merge commits
            echo "ðŸ”„ Syncing repository..."
            timeout 60 git fetch origin main 2>/dev/null
            if [ $? -ne 0 ]; then
              echo "âš ï¸  Git fetch with timeout failed, retrying..."
              sleep 10
              git fetch origin main
              if [ $? -ne 0 ]; then
                echo "âŒ Git fetch failed"
                EXIT_STATUS=1
              fi
            fi
            
            if [ $EXIT_STATUS -eq 0 ]; then
              git reset --hard origin/main 2>/dev/null || {
                echo "âš ï¸  Git reset failed, continuing anyway"
              }
            fi

            # Pull latest backend image with retry logic
            echo "ðŸ“¥ Pulling backend image (with retry logic)..."
            
            # Verify Docker is still accessible before pulling
            docker --version >/dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "âŒ Docker daemon became inaccessible, attempting restart..."
              sudo systemctl start docker 2>/dev/null || sudo service docker start 2>/dev/null || true
              sleep 5
            fi
            
            max_pull_attempts=3
            pull_attempt=0
            
            while [ $pull_attempt -lt $max_pull_attempts ]; do
              timeout 300 docker compose pull backend 2>/dev/null
              PULL_EXIT=$?
              if [ $PULL_EXIT -eq 0 ] || [ $PULL_EXIT -eq 124 ]; then
                echo "âœ… Backend image pull completed"
                break
              fi
              pull_attempt=$((pull_attempt + 1))
              if [ $pull_attempt -lt $max_pull_attempts ]; then
                echo "âš ï¸  Image pull attempt $pull_attempt/$max_pull_attempts failed, waiting 10s..."
                sleep 10
              fi
            done

            if [ $pull_attempt -ge $max_pull_attempts ]; then
              echo "âš ï¸  Could not pull new image, using existing local image..."
            fi

            # Stop and clean up existing containers
            echo "â¹ï¸  Stopping backend service..."
            docker compose stop backend 2>/dev/null || true
            sleep 1
            docker compose down 2>/dev/null || true
            sleep 2

            # Clean up dangling resources
            echo "ðŸ§¹ Cleaning up dangling resources..."
            docker container prune -f --filter "until=1h" 2>/dev/null || true
            docker image prune -f 2>/dev/null || true

            # Start the backend service with retry logic
            echo "ðŸš€ Starting backend service..."
            
            # Verify Docker is accessible before starting
            docker --version >/dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "âŒ Docker daemon not accessible before starting containers, attempting restart..."
              sudo systemctl start docker 2>/dev/null || sudo service docker start 2>/dev/null || {
                echo "âŒ Failed to start Docker daemon"
                EXIT_STATUS=1
              }
              sleep 5
            fi
            
            if [ $EXIT_STATUS -eq 0 ]; then
              start_attempt=0
              max_start_attempts=5
              start_success=0
              
              while [ $start_attempt -lt $max_start_attempts ]; do
                if docker compose up -d backend 2>&1 | tee /tmp/start_output.log; then
                  echo "âœ… Backend container started successfully"
                  start_success=1
                  break
                fi
                
                start_attempt=$((start_attempt + 1))
                if [ $start_attempt -lt $max_start_attempts ]; then
                  echo "âš ï¸  Start attempt $start_attempt/$max_start_attempts failed, retrying in 5s..."
                  sleep 5
                fi
              done

              if [ $start_success -eq 0 ]; then
                echo "âŒ Failed to start backend after $max_start_attempts attempts"
                docker compose logs backend 2>/dev/null || echo "Could not retrieve logs"
                EXIT_STATUS=1
              fi
            fi

            # Wait for container to stabilize (backend needs 180s start period)
            echo "â³ Waiting for backend container to stabilize..."
            sleep 30

            # Wait additional time for backend start period
            echo "â³ Allowing backend 180s start period to complete..."
            sleep 60
            
            # Check if backend container is actually running
            echo "ðŸ” Checking backend container status..."
            
            # Verify Docker is accessible before checking container
            docker --version >/dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "âŒ Docker daemon not accessible before container check, attempting restart..."
              sudo systemctl start docker 2>/dev/null || sudo service docker start 2>/dev/null || {
                echo "âŒ Failed to start Docker daemon"
                EXIT_STATUS=1
              }
              sleep 5
            fi
            
            if [ $EXIT_STATUS -eq 0 ]; then
              container_running=$(docker compose ps -q backend | xargs docker inspect --format='{{.State.Running}}' 2>/dev/null || echo "false")
              echo "Container running: $container_running"
              
              if [ "$container_running" != "true" ]; then
                echo "âŒ Backend container is not running!"
                echo "Container status:"
                docker compose ps backend 2>/dev/null || true
                echo "Container logs:"
                docker compose logs backend --tail 30 2>/dev/null || true
                EXIT_STATUS=1
              fi
            fi

            # Check backend health
            if [ $EXIT_STATUS -eq 0 ]; then
              echo "ðŸ¥ Checking backend health..."
              max_health_attempts=30
              health_attempt=0
              health_success=0
              
              while [ $health_attempt -lt $max_health_attempts ]; do
                echo "ðŸ” Health check attempt $((health_attempt + 1))/$max_health_attempts..."
                
                # Try container health check first
                echo "  Trying internal health check..."
                if docker compose exec -T backend curl -sf http://127.0.0.1:8000/health >/dev/null 2>&1; then
                  echo "âœ… Backend is healthy and responding (internal check)"
                  health_success=1
                  break
                else
                  echo "  âŒ Internal health check failed"
                fi
                
                # Fallback: Check external health
                echo "  Trying external health check..."
                if curl -sf http://127.0.0.1:8000/health >/dev/null 2>&1; then
                  echo "âœ… Backend is healthy and responding (external check)"
                  health_success=1
                  break
                else
                  echo "  âŒ External health check failed"
                fi
                
                # Fallback: Check if container is running and not in unhealthy state
                echo "  Checking container health status..."
                container_status=$(docker compose ps -q backend | xargs docker inspect --format='{{.State.Health.Status}}' 2>/dev/null || echo "unknown")
                echo "  Container health status: $container_status"
                if [ "$container_status" = "healthy" ]; then
                  echo "âœ… Backend container reports healthy status"
                  health_success=1
                  break
                fi
                
                # Additional debugging every 5 attempts
                if [ $((health_attempt % 5)) -eq 0 ]; then
                  echo "  ðŸ“Š Debug info (attempt $((health_attempt + 1))):"
                  docker compose ps backend 2>/dev/null || true
                fi
                
                health_attempt=$((health_attempt + 1))
                if [ $health_attempt -lt $max_health_attempts ]; then
                  echo "â³ Health check attempt $health_attempt/$max_health_attempts, retrying in 2s..."
                  sleep 2
                fi
              done

              if [ $health_success -eq 0 ]; then
                echo "âš ï¸  Backend health check timed out after 1 minute"
                echo "Container status:"
                docker compose ps backend 2>/dev/null || true
                echo "Container health status:"
                docker compose ps --format 'table {{.Name}}\t{{.Status}}\t{{.Ports}}' backend 2>/dev/null || true
                echo "Recent logs:"
                docker compose logs backend --tail 50 2>/dev/null || true
                echo "Container inspect:"
                docker compose ps -q backend | xargs docker inspect --format='{{json .State}}' 2>/dev/null || true
                echo "Network info:"
                docker network ls 2>/dev/null || true
                echo "Port binding:"
                docker compose ps --format '{{.Name}}: {{.Ports}}' backend 2>/dev/null || true
                EXIT_STATUS=1
              else
                echo "âœ¨ Backend deployment completed successfully!"
              fi
            fi

            # Exit with final status
            exit $EXIT_STATUS



            
