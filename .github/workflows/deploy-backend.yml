name: Build & Deploy Backend

on:
  push:
    branches: ["main"]
    paths:
      - "backend/**"
      - ".github/workflows/deploy-backend.yml"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/hypersend-backend

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Wait for Docker Hub availability (retry logic)
        run: |
          echo "üîÑ Checking Docker Hub connectivity..."
          max_attempts=5
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if curl -s -m 10 https://registry-1.docker.io/v2/ > /dev/null 2>&1; then
              echo "‚úÖ Docker Hub is reachable"
              exit 0
            fi
            attempt=$((attempt + 1))
            if [ $attempt -lt $max_attempts ]; then
              wait_time=$((2 ** attempt))  # Exponential backoff: 2s, 4s, 8s, 16s
              echo "‚è≥ Docker Hub not responding (attempt $attempt/$max_attempts), waiting ${wait_time}s..."
              sleep $wait_time
            fi
          done
          echo "‚ö†Ô∏è  Docker Hub still not responding, proceeding with login (retry in action will handle)"
          exit 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
        
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        timeout-minutes: 3

      - name: Build & push backend image
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:latest
          cache-to: type=registry,ref=${{ env.IMAGE_NAME }}:latest,mode=max
          build-args: |
            BUILDKIT_CONTEXT_KEEP_GIT_DIR=1
            BUILDKIT_INLINE_CACHE=1
        timeout-minutes: 35
        env:
          DOCKER_CLIENT_TIMEOUT: 600
          COMPOSE_HTTP_TIMEOUT: 600

      - name: Deploy to VPS (Docker Compose, password SSH)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          timeout: 30m
          command_timeout: 30m
          script_stop: true
          script: |
            set -e
            cd /hypersend/Hypersend || { echo "‚ùå Directory /hypersend/Hypersend not found"; exit 1; }

            echo "üì¶ Starting backend deployment..."

            # Configure Docker daemon with increased timeouts to handle network issues
            echo "üîß Configuring Docker daemon for network resilience..."
            if [ ! -d "/etc/docker" ]; then
              sudo mkdir -p /etc/docker
            fi
            
            # Add timeout configuration to Docker daemon (only if not exists)
            if [ ! -f "/etc/docker/daemon.json" ]; then
              echo '{"default-ulimit": {"nofile": {"Name": "nofile", "Hard": 65535, "Soft": 65535}}, "log-driver": "json-file", "log-opts": {"max-size": "100m"}, "registry-mirrors": ["https://mirror.gcr.io"], "max-concurrent-uploads": 5}' | sudo tee /etc/docker/daemon.json > /dev/null
              # Check if docker is running before restart
              if sudo systemctl is-active --quiet docker; then
                echo "üîÑ Restarting Docker daemon..."
                sudo systemctl restart docker || {
                  echo "‚ö†Ô∏è  Docker restart failed, trying reload..."
                  sudo systemctl reload docker || {
                    echo "‚ö†Ô∏è  Docker reload failed, continuing with current configuration..."
                  }
                }
              else
                echo "üöÄ Starting Docker daemon..."
                sudo systemctl start docker || {
                  echo "‚ö†Ô∏è  Docker start failed, continuing anyway..."
                }
              fi
              sleep 5
            else
              echo "‚úÖ Docker daemon configuration already exists"
            fi

            # Safely sync repo with remote without creating merge commits
            # (keeps untracked files like .env, but resets tracked files to origin/main)
            echo "üîÑ Syncing repository..."
            # Fix: git fetch doesn't have --timeout option, use timeout command instead
            timeout 60 git fetch origin main || {
              echo "‚ö†Ô∏è  Git fetch with timeout failed, retrying..."
              sleep 10
              git fetch origin main || { echo "‚ùå Git fetch failed"; exit 1; }
            }
            git reset --hard origin/main

            # Pull latest backend image with retry logic
            echo "üì• Pulling backend image (with retry logic)..."
            max_pull_attempts=3
            pull_attempt=0
            until [ $pull_attempt -ge $max_pull_attempts ]; do
              if timeout 300 docker compose pull backend 2>/dev/null || [ $? -eq 124 ]; then
                # 124 = timeout, but we try to proceed anyway
                echo "‚úÖ Backend image pull completed"
                break
              fi
              pull_attempt=$((pull_attempt + 1))
              if [ $pull_attempt -lt $max_pull_attempts ]; then
                wait_time=$((10 * pull_attempt))
                echo "‚ö†Ô∏è  Image pull attempt $pull_attempt/$max_pull_attempts failed, waiting ${wait_time}s..."
                sleep $wait_time
              fi
            done

            if [ $pull_attempt -ge $max_pull_attempts ]; then
              echo "‚ö†Ô∏è  Could not pull new image after $max_pull_attempts attempts, using existing local image..."
            fi

            # Function to safely stop backend service
            stop_backend_safe() {
              echo "‚èπÔ∏è  Stopping backend service..."
              
              # Try graceful stop first
              docker compose stop backend 2>/dev/null || true
              sleep 2
              
              # Then remove with retries
              local max_stop_attempts=5
              local stop_attempt=0
              while [ $stop_attempt -lt $max_stop_attempts ]; do
                # Try to remove
                if docker compose down 2>&1 | tee /tmp/docker_output.log; then
                  echo "‚úÖ Backend stopped successfully"
                  return 0
                fi
                
                # Check if error is "removal in progress"
                if grep -q "removal.*in progress" /tmp/docker_output.log; then
                  stop_attempt=$((stop_attempt+1))
                  echo "‚è≥ Docker daemon busy (removal in progress), attempt $stop_attempt/$max_stop_attempts..."
                  sleep 3
                else
                  # Different error, might be safe to continue
                  echo "‚ö†Ô∏è  docker compose down had issues, continuing..."
                  break
                fi
              done
              
              if [ $stop_attempt -ge $max_stop_attempts ]; then
                echo "‚ö†Ô∏è  Could not cleanly stop via compose, forcing container removal..."
                # Force remove any remaining containers
                docker ps -a --filter "name=hypersend_backend" --format "{{.ID}}" 2>/dev/null | \
                  while read container_id; do
                    if [ -n "$container_id" ]; then
                      docker rm -f "$container_id" 2>/dev/null || true
                    fi
                  done
              fi
              
              # Wait for Docker daemon to finish all operations
              echo "üîÑ Waiting for Docker daemon to finish cleanup..."
              sleep 3
            }

            # Execute safe stop
            stop_backend_safe

            # Clean up any dangling containers/images from previous deployments
            echo "üßπ Cleaning up dangling resources..."
            docker container prune -f --filter "until=1h" 2>/dev/null || true
            docker image prune -f 2>/dev/null || true

            # Start the backend service with robust retry logic
            echo "üöÄ Starting backend service..."
            n=0
            max_start_attempts=5
            until [ "$n" -ge $max_start_attempts ]; do
              if docker compose up -d backend 2>&1 | tee /tmp/start_output.log; then
                echo "‚úÖ Backend container created successfully"
                break
              fi
              
              # Check if it's a transient error
              if grep -q "removal.*in progress\|bind.*address already in use" /tmp/start_output.log; then
                n=$((n+1))
                if [ "$n" -lt $max_start_attempts ]; then
                  echo "‚ö†Ô∏è  Transient error on attempt $n/$max_start_attempts, waiting 5s..."
                  sleep 5
                fi
              else
                # Unrecoverable error
                echo "‚ùå Unrecoverable error starting service"
                cat /tmp/start_output.log
                exit 1
              fi
            done

            if [ "$n" -ge $max_start_attempts ]; then
              echo "‚ùå Failed to start backend after $max_start_attempts attempts"
              docker compose logs backend 2>/dev/null || true
              exit 1
            fi

            # Wait for container to be fully running
            echo "‚è≥ Waiting for backend container to stabilize..."
            sleep 5

            # Wait for service to be healthy
            echo "üè• Checking backend health..."
            max_health_attempts=30
            health_attempt=0
            while [ $health_attempt -lt $max_health_attempts ]; do
              if docker compose exec -T backend curl -sf http://127.0.0.1:8000/health > /dev/null 2>&1; then
                echo "‚úÖ Backend is healthy and responding"
                break
              fi
              health_attempt=$((health_attempt+1))
              if [ $health_attempt -lt $max_health_attempts ]; then
                echo "‚è≥ Health check attempt $health_attempt/$max_health_attempts, retrying in 2s..."
                sleep 2
              fi
            done

            if [ $health_attempt -eq $max_health_attempts ]; then
              echo "‚ö†Ô∏è  Backend health check timed out after 1 minute"
              echo "Container status:"
              docker compose ps backend
              echo "Recent logs:"
              docker compose logs backend --tail 20
            else
              echo "‚ú® Backend deployment completed successfully!"
            fi



            
