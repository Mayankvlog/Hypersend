name: Build & Deploy Backend

on:
  push:
    branches: ["main"]
    paths:
      - "backend/**"
      - ".github/workflows/deploy-backend.yml"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/hypersend-backend
      FRONTEND_IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/hypersend-frontend

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & push backend image
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}

      - name: Build & push frontend image
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE_NAME }}:latest
            ${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}

      - name: Deploy to VPS (Docker Compose, password SSH)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          script: |
            set -e
            cd /hypersend/Hypersend || { echo "âŒ Directory /hypersend/Hypersend not found"; exit 1; }

            echo "ðŸ“¦ Starting backend deployment..."

            # Safely sync repo with remote without creating merge commits
            # (keeps untracked files like .env, but resets tracked files to origin/main)
            echo "ðŸ”„ Syncing repository..."
            git fetch origin main
            git reset --hard origin/main

            # Pull latest backend & frontend images
            echo "ðŸ“¥ Pulling backend image..."
            docker compose pull backend 2>/dev/null || { echo "âš ï¸  Backend image pull had issues, continuing..."; }
            echo "ðŸ“¥ Pulling frontend image..."
            docker compose pull frontend 2>/dev/null || { echo "âš ï¸  Frontend image pull had issues, continuing..."; }

            # Function to safely stop backend service
            stop_backend_safe() {
              echo "â¹ï¸  Stopping backend service..."
              
              # Try graceful stop first
              docker compose stop backend 2>/dev/null || true
              sleep 2
              
              # Then remove with retries
              local max_stop_attempts=5
              local stop_attempt=0
              while [ $stop_attempt -lt $max_stop_attempts ]; do
                # Try to remove
                if docker compose down 2>&1 | tee /tmp/docker_output.log; then
                  echo "âœ… Backend stopped successfully"
                  return 0
                fi
                
                # Check if error is "removal in progress"
                if grep -q "removal.*in progress" /tmp/docker_output.log; then
                  stop_attempt=$((stop_attempt+1))
                  echo "â³ Docker daemon busy (removal in progress), attempt $stop_attempt/$max_stop_attempts..."
                  sleep 3
                else
                  # Different error, might be safe to continue
                  echo "âš ï¸  docker compose down had issues, continuing..."
                  break
                fi
              done
              
              if [ $stop_attempt -ge $max_stop_attempts ]; then
                echo "âš ï¸  Could not cleanly stop via compose, forcing container removal..."
                # Force remove any remaining containers
                docker ps -a --filter "name=hypersend_backend" --format "{{.ID}}" 2>/dev/null | \
                  while read container_id; do
                    if [ -n "$container_id" ]; then
                      docker rm -f "$container_id" 2>/dev/null || true
                    fi
                  done
              fi
              
              # Wait for Docker daemon to finish all operations
              echo "ðŸ”„ Waiting for Docker daemon to finish cleanup..."
              sleep 3
            }

            # Execute safe stop
            stop_backend_safe

            # Clean up any dangling containers/images from previous deployments
            echo "ðŸ§¹ Cleaning up dangling resources..."
            docker container prune -f --filter "until=1h" 2>/dev/null || true
            docker image prune -f 2>/dev/null || true

            # Start the backend service with robust retry logic
            echo "ðŸš€ Starting backend service..."
            n=0
            max_start_attempts=5
            until [ "$n" -ge $max_start_attempts ]; do
              if docker compose up -d backend 2>&1 | tee /tmp/start_output.log; then
                echo "âœ… Backend container created successfully"
                break
              fi
              
              # Check if it's a transient error
              if grep -q "removal.*in progress\|bind.*address already in use" /tmp/start_output.log; then
                n=$((n+1))
                if [ "$n" -lt $max_start_attempts ]; then
                  echo "âš ï¸  Transient error on attempt $n/$max_start_attempts, waiting 5s..."
                  sleep 5
                fi
              else
                # Unrecoverable error
                echo "âŒ Unrecoverable error starting service"
                cat /tmp/start_output.log
                exit 1
              fi
            done

            if [ "$n" -ge $max_start_attempts ]; then
              echo "âŒ Failed to start backend after $max_start_attempts attempts"
              docker compose logs backend 2>/dev/null || true
              exit 1
            fi

            # Wait for container to be fully running
            echo "â³ Waiting for backend container to stabilize..."
            sleep 5

            # Wait for service to be healthy
            echo "ðŸ¥ Checking backend health..."
            max_health_attempts=30
            health_attempt=0
            while [ $health_attempt -lt $max_health_attempts ]; do
              if docker compose exec -T backend curl -sf http://localhost:8000/health > /dev/null 2>&1; then
                echo "âœ… Backend is healthy and responding"
                break
              fi
              health_attempt=$((health_attempt+1))
              if [ $health_attempt -lt $max_health_attempts ]; then
                echo "â³ Health check attempt $health_attempt/$max_health_attempts, retrying in 2s..."
                sleep 2
              fi
            done

            if [ $health_attempt -eq $max_health_attempts ]; then
              echo "âš ï¸  Backend health check timed out after 1 minute"
              echo "Container status:"
              docker compose ps backend
              echo "Recent logs:"
              docker compose logs backend --tail 20
            else
              echo "âœ¨ Backend deployment completed successfully!"
            fi

            echo "ðŸŒ Starting frontend service..."
            if docker compose up -d frontend 2>&1 | tee /tmp/frontend_start.log; then
              echo "âœ… Frontend container started successfully"
            else
              echo "âš ï¸ Frontend failed to start, showing recent logs..."
              docker compose logs frontend --tail 20 2>/dev/null || true
            fi



            
